- [x] . What is algorithmic complexity? Time complexity (O(n), O(log n), O(n^2)) and space complexity.
1. Differences between arrays and linked lists: features and distinctions.
2. Queue vs stack: differences, use cases, and when to use each.
3. How does hashing work and what are hash collisions: hash functions and collision resolution methods.
4. How are heaps structured (Heap): types of heaps and their applications.
5. Sorting algorithms: merge sort and other common methods (quick sort, insertion sort, etc.).
6. Data structures for searching: trees (binary trees and search trees).
7. Red-black trees and other balanced trees: how they work and when to use them.
8. Segment tree: how it works and when to use it.
9. How Trie (prefix tree) works and when to use it.
10. Basics of working with graphs: graph representations (adjacency lists, adjacency matrices) and classification (weighted and unweighted graphs).
11. Graph search: differences between depth-first search (DFS) and breadth-first search (BFS).
12. Tarjan's algorithm for finding strongly connected components in a graph.
13. Dijkstra's algorithm for finding the shortest path in a graph.
14. String searching algorithms: examples (e.g., Knuth-Morris-Pratt algorithm).
15. Dynamic programming: principles, problem examples, and algorithms (including the knapsack problem and greedy algorithms).
16. Huffman algorithm: how it works and where it's applied.
17. Reverse Polish notation (RPN): what it is and how to evaluate expressions in RPN.
18. Search and binary search: how they work, when to apply them, and which one is best in different situations.
19. Backtracking: solving problems with search (e.g., Sudoku, n-queens problem).